<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Loader White Theme</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff; /* Arkaplan Beyaz yapıldı */
        }
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* Loader Arkaplanı Beyaz yapıldı */
            z-index: 9999;
        }
        #loader-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #main-content {
            display: none;
            color: black; /* İçerik yazısı Siyah yapıldı */
            text-align: center;
            padding-top: 50vh;
        }
    </style>
</head>
<body>
    <div id="loader">
        <canvas id="loader-canvas"></canvas>
    </div>
    <div id="main-content">
        <h1>Content Loaded!</h1>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        // --- Basic Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('loader-canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // --- Textures and Materials ---
        
        function createTextTexture(text, heightScale = 1.0, fontWeight = 900) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            canvas.width = 8192; 
            canvas.height = 4096; 

            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Hesaplama
            const textToRender = text + " "; 

            // 2. Referans ölçüm
            let fontSize = 100;
            context.font = `${fontWeight} ${fontSize}px 'Inter', sans-serif`;
            const metrics = context.measureText(textToRender);
            const textWidth = metrics.width;
            
            // 3. Genişlik Oturtma
            const scaleFactor = canvas.width / textWidth;
            const finalFontSize = fontSize * scaleFactor;
            
            // 4. Çizim Ayarları
            context.font = `${fontWeight} ${finalFontSize}px 'Inter', sans-serif`;
            
            // --- RENK DEĞİŞİKLİĞİ BURADA YAPILDI ---
            context.fillStyle = 'black'; // Yazı rengi Siyah yapıldı (Eskiden white idi)
            
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // --- YÜKSEKLİK AYARI (Esnetme İşlemi) ---
            context.save(); 
            
            context.translate(canvas.width / 2, canvas.height / 2);
            context.scale(1, heightScale);
            context.fillText(textToRender, 0, 0);
            
            context.restore(); 
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; 
            texture.wrapT = THREE.ClampToEdgeWrapping; 
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;
            
            return texture;
        }

        // --- Create Loader Globes ---
        function createTextSphere(text, heightScale, fontWeight) {
            const group = new THREE.Group(); 

            const textTexture = createTextTexture(text, heightScale, fontWeight);
            
            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false 
            });
            const textSphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 64, 64), textMaterial);
            group.add(textSphere);

            group.userData.textTexture = textTexture;

            return group;
        }

        // --- YAZI BOYUTLARINI BURADAN AYARLIYORSUN ---
        const masterGroup = new THREE.Group();
        masterGroup.rotation.x = Math.PI / 12; // 15 degrees
        scene.add(masterGroup);

        const globe1 = createTextSphere('AI-POWERED   ROTTEN   DETECTION   SYSTEM  ', 2, 900); 
        const globe2 = createTextSphere('IMAGE UPLOAD      »      OBJECT DETECTION      »      BOUNDING BOX      »      QUALITY CLASSIFICATION      »     ', 1, 400);
        masterGroup.add(globe1, globe2);

        // --- Camera Orbit Logic ---
        const mouse = { x: 0, y: 0 };
        const target = { x: 0, y: 0 };
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; 
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Dönüş hızı
            globe1.userData.textTexture.offset.x -= 0.0005;
            globe2.userData.textTexture.offset.x -= 0.001; 

            // Camera orbit calculation
            target.x += (mouse.y * 0.4 - target.x) * 0.05;
            target.y += (mouse.x * 0.4 - target.y) * 0.05;

            const r = 6;
            const phi = Math.PI / 2 - target.x - 0.2; // Camera vertical offset
            const theta = target.y;

            camera.position.x = r * Math.sin(phi) * Math.cos(theta);
            camera.position.y = r * Math.cos(phi);
            camera.position.z = r * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }
        animate();

        // --- GSAP Animations ---
        // Both start from bottom, different x positions to avoid collision.
        globe1.position.set(1.5, -15, 0); // Start from right
        globe2.position.set(-1.5, -15, 0); // Start from left

        const introTl = gsap.timeline({ delay: 1 });

        // globe1 starts first
        introTl.to(globe1.position, { x: 0, y: 0.35, duration: 2.5, ease: 'power4.out' });
        // globe2 starts 0.5s later, is faster, and comes from the other side
        introTl.to(globe2.position, { x: 0, y: -0.15, duration: 1.8, ease: 'power4.out' }, '-=2.0'); // Starts 0.5s after globe1

        // Exit Animation
        setTimeout(() => {
            runExitAnimation();
        }, 5000); 

        function runExitAnimation() {
            const exitTl = gsap.timeline();
            // globe2 (bottom) exits first and faster, downwards and to the left
            exitTl.to(globe2.position, {
                x: -1.5,
                y: -15,
                duration: 1.0,
                ease: 'power4.in'
            });
            // globe1 (top) exits second and slower, downwards and to the right
            exitTl.to(globe1.position, {
                x: 1.5,
                y: -15,
                duration: 1.5,
                ease: 'power4.in'
            }, 0.2); // Delay start by 0.2s

            exitTl.to('#loader', { 
                opacity: 0, 
                duration: 1, 
                onComplete: () => {
                    document.getElementById('loader').style.display = 'none';
                }
            }, 0.8); // Start fade at 0.8s
            exitTl.fromTo('#main-content', { opacity: 0 }, { opacity: 1, display: 'block', duration: 1}, '-=0.5');
        }
        
        // --- Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>