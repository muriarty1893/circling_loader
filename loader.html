<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Loader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            z-index: 9999;
        }
        #loader-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #main-content {
            display: none;
            color: white;
            text-align: center;
            padding-top: 50vh;
        }
    </style>
</head>
<body>
    <div id="loader">
        <canvas id="loader-canvas"></canvas>
    </div>
    <div id="main-content">
        <h1>Content Loaded!</h1>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        // --- Basic Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('loader-canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // --- Textures and Materials ---
        function createTextTexture(text, fontSize, canvasHeight = 1024) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            // Use a very high resolution canvas for crisp text
            canvas.width = 8192;
            canvas.height = canvasHeight; // Use parameterized height

            // Transparent background
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Adjust font size based on the new dynamic canvas height
            const adjustedFontSize = fontSize * (canvas.height / 512);
            context.font = `900 ${adjustedFontSize}px 'Inter', sans-serif`;
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Repeat text to fill the wider texture
            const textMetrics = context.measureText(text + ' ');
            const repeatCount = Math.ceil(canvas.width / textMetrics.width) * 2; // More repetitions
            const fullText = (text + '         ').repeat(repeatCount);
            context.fillText(fullText, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            // Anisotropic filtering for better quality on angled surfaces
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;
            return texture;
        }

        // --- Create Loader Globes ---
        function createTextSphere(text, fontSize, canvasHeight) {
            const group = new THREE.Group(); 

            const textTexture = createTextTexture(text, fontSize, canvasHeight);
            // The material is now transparent where there's no text
            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
                side: THREE.DoubleSide, // Render both sides to prevent text from disappearing
                depthWrite: false // Crucial for correct transparency sorting
            });
            const textSphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 64, 64), textMaterial);
            group.add(textSphere);

            group.userData.textTexture = textTexture; // For animation

            return group;
        }

        const globe1 = createTextSphere('CREATIVE DESIGNER', 90);
        const globe2 = createTextSphere('UX/UI & WEB - UX/UI & WEB', 40, 256);

        scene.add(globe1, globe2);

        // --- Camera Orbit Logic ---
        const mouse = { x: 0, y: 0 };
        const target = { x: 0, y: 0 };
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; // Invert Y
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            // Animate texture offset for scrolling text
            globe1.userData.textTexture.offset.x -= 0.001;
            globe2.userData.textTexture.offset.x -= 0.002; // Same direction, but faster

            // Camera orbit calculation
            target.x += (mouse.y * 0.4 - target.x) * 0.05;
            target.y += (mouse.x * 0.4 - target.y) * 0.05;

            const r = 6;
            const phi = Math.PI / 2 - target.x;
            const theta = target.y; // Removed PI offset for more direct control

            camera.position.x = r * Math.sin(phi) * Math.cos(theta);
            camera.position.y = r * Math.cos(phi);
            camera.position.z = r * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }
        animate();

        // --- GSAP Animations ---
        // 1. Intro Animation
        globe1.position.y = -8;
        globe2.position.y = -8;
        const introTl = gsap.timeline({ delay: 1 });
        // Increased vertical separation
        introTl.to(globe1.position, { y: 0.25, duration: 2.5, ease: 'power4.out' });
        introTl.to(globe2.position, { y: -0.25, duration: 2.5, ease: 'power4.out' }, '-=2.2');

        // 2. Exit Animation (triggered by a simulated load)
        setTimeout(() => {
            runExitAnimation();
        }, 5000); // Simulate a 5-second load time

        function runExitAnimation() {
            const exitTl = gsap.timeline();
            exitTl.to([globe1.position, globe2.position], { 
                y: -10, 
                duration: 1.5, 
                ease: 'power4.in',
                stagger: 0.1
            });
            exitTl.to('#loader', { 
                opacity: 0, 
                duration: 1, 
                onComplete: () => {
                    document.getElementById('loader').style.display = 'none';
                }
            }, '-=0.8');
            exitTl.fromTo('#main-content', { opacity: 0 }, { opacity: 1, display: 'block', duration: 1}, '-=0.5');
        }
        
        // --- Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
